/**************************************************************************************
实验现象：下载程序后，LED点阵显示数字0
		  
接线说明： (具体接线图可见开发攻略对应实验的“实验现象”章节)
		   1，单片机-->74HC595模块
		   		P34-->SE
		   		P35-->RC
				P36-->SC
		   2，74HC595(A)模块输出-->LED双色点阵模块
		   		J27-->J28
		   3，74HC595(B)模块输出-->LED双色点阵模块
		   		J32-->J34	
	
注意事项：																				

  
***************************************************************************************/

#include "reg51.h" //此文件中定义了单片机的一些特殊功能寄存器
#include "intrins.h"

typedef unsigned int u16; //对数据类型进行声明定义
typedef unsigned char u8;

//--定义使用的IO口--//
// sbit SRCLK = P1 ^ 5;
// sbit RCLK = P1 ^ 7;
// sbit SER = P1 ^ 6;
sbit SRCLK = P2 ^ 1;
sbit RCLK = P2 ^ 0;
sbit SER = P2 ^ 2;

//定义LED点阵的位选，也就是类似于数码管的位选，因为要对其动态扫描操作
//数组前16位和后16位数据正好是相反的，也就是说先让第3个595输出低电平，然后再让第4个595输出低电平

u8 code ledwei[] =
	{
		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

u8 code ledmeng[] =
	{
		0x04, 0xc4, 0x44, 0x44, 0x4f, 0xc4, 0x04, 0x04, 0xe4, 0x24, 0x2f, 0x24, 0x24, 0xe4, 0x04, 0x00,
		0x00, 0x3f, 0x12, 0x12, 0x12, 0x3f, 0x80, 0x40, 0x3f, 0x09, 0x09, 0x49, 0x89, 0x7f, 0x00, 0x00};

/*******************************************************************************
* 函 数 名         : delay
* 函数功能		   : 延时函数，i=1时，大约延时10us
*******************************************************************************/
void delay(u16 i)
{
	while (i--)
		;
}

/*******************************************************************************
* 函 数 名         : Hc595SendByte(u8 dat1,u8 dat2,u8 dat3,u8 dat4)
* 函数功能		   : 通过595发送四个字节的数据
* 输    入         : dat1：第4个595输出数值
*                  * dat2: 第3个595输出数值
*                  * dat3：第2个595输出数值
*                  * dat4：第1个595输出数值
* 输    出         : 无
*******************************************************************************/
void Hc595SendByte(u8 dat1, u8 dat2, u8 dat3, u8 dat4)
{
	u8 a;

	SRCLK = 1;
	RCLK = 1;

	for (a = 0; a < 8; a++) //发送8位数
	{
		SER = dat1 >> 7; //从最高位开始发送
		dat1 <<= 1;

		SRCLK = 0; //发送时序
		_nop_();
		_nop_();
		SRCLK = 1;
	}

	for (a = 0; a < 8; a++) //发送8位数
	{
		SER = dat2 >> 7; //从最高位开始发送
		dat2 <<= 1;

		SRCLK = 0; //发送时序
		_nop_();
		_nop_();
		SRCLK = 1;
	}

	for (a = 0; a < 8; a++) //发送8位数
	{
		SER = dat3 >> 7; //从最高位开始发送
		dat3 <<= 1;

		SRCLK = 0; //发送时序
		_nop_();
		_nop_();
		SRCLK = 1;
	}

	for (a = 0; a < 8; a++) //发送8位数
	{
		SER = dat4 >> 7; //从最高位开始发送
		dat4 <<= 1;

		SRCLK = 0; //发送时序
		_nop_();
		_nop_();
		SRCLK = 1;
	}

	RCLK = 0;
	_nop_();
	_nop_();
	RCLK = 1;
}


/*******************************************************************************
* 函 数 名         : Timer0Init
* 函数功能		   : 定时器0初始化
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
// void Timer0Init()
// {
// 	TMOD |= 0X01; //选择为定时器0模式，工作方式1，仅用TR0打开启动。

// 	TH0 = 0XB1; //给定时器赋初值，定时1ms
// 	TL0 = 0XE0;
// 	ET0 = 1; //打开定时器0中断允许
// 	EA = 1;	 //打开总中断
// 	TR0 = 1; //打开定时器
// }

/*******************************************************************************
* 函 数 名         : void Timer0() interrupt 1
* 函数功能		   : 定时器0中断函数
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
// void Timer0() interrupt 1
// {
// 	// static u16 i;
// 	u8 j;
// 	TH0 = 0XBF; //给定时器赋初值，定时1ms
// 	TL0 = 0XFF;
// 	// i++;
// 	// if (i == 1000)
// 	// {
// 	// 	i = 0;
// 		for (j = 0; j < 16; j++)
// 		{
// 			Hc595SendByte(~ledwei[j + 16], ~ledwei[j], ledmeng[16 + j], ledmeng[j]);
// 			delay(10);
// 		}
// 	// }
// }


/*******************************************************************************
* 函 数 名       : main
* 函数功能		 : 主函数
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
// void main()
// {
// 	u8 i;

// 	while(1)
// 	{
// 		for(i=0;i<16;i++)
// 		{
// 			Hc595SendByte(~ledwei[i+16],~ledwei[i],ledmeng[16+i],ledmeng[i]);
// 			delay(10);
// 		}
// 	}
// }